// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol.proto

#ifndef PROTOBUF_INCLUDED_protocol_2eproto
#define PROTOBUF_INCLUDED_protocol_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_protocol_2eproto 

namespace protobuf_protocol_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_protocol_2eproto
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class DirectAttack;
class DirectAttackDefaultTypeInternal;
extern DirectAttackDefaultTypeInternal _DirectAttack_default_instance_;
class EndTurn;
class EndTurnDefaultTypeInternal;
extern EndTurnDefaultTypeInternal _EndTurn_default_instance_;
class GameState;
class GameStateDefaultTypeInternal;
extern GameStateDefaultTypeInternal _GameState_default_instance_;
class GameState_UnitsEntry_DoNotUse;
class GameState_UnitsEntry_DoNotUseDefaultTypeInternal;
extern GameState_UnitsEntry_DoNotUseDefaultTypeInternal _GameState_UnitsEntry_DoNotUse_default_instance_;
class Move;
class MoveDefaultTypeInternal;
extern MoveDefaultTypeInternal _Move_default_instance_;
class Position;
class PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class Spawn;
class SpawnDefaultTypeInternal;
extern SpawnDefaultTypeInternal _Spawn_default_instance_;
class Tile;
class TileDefaultTypeInternal;
extern TileDefaultTypeInternal _Tile_default_instance_;
class Unit;
class UnitDefaultTypeInternal;
extern UnitDefaultTypeInternal _Unit_default_instance_;
namespace google {
namespace protobuf {
template<> ::Command* Arena::CreateMaybeMessage<::Command>(Arena*);
template<> ::DirectAttack* Arena::CreateMaybeMessage<::DirectAttack>(Arena*);
template<> ::EndTurn* Arena::CreateMaybeMessage<::EndTurn>(Arena*);
template<> ::GameState* Arena::CreateMaybeMessage<::GameState>(Arena*);
template<> ::GameState_UnitsEntry_DoNotUse* Arena::CreateMaybeMessage<::GameState_UnitsEntry_DoNotUse>(Arena*);
template<> ::Move* Arena::CreateMaybeMessage<::Move>(Arena*);
template<> ::Position* Arena::CreateMaybeMessage<::Position>(Arena*);
template<> ::Spawn* Arena::CreateMaybeMessage<::Spawn>(Arena*);
template<> ::Tile* Arena::CreateMaybeMessage<::Tile>(Arena*);
template<> ::Unit* Arena::CreateMaybeMessage<::Unit>(Arena*);
}  // namespace protobuf
}  // namespace google

// ===================================================================

class GameState_UnitsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<GameState_UnitsEntry_DoNotUse, 
    ::google::protobuf::uint64, ::Unit,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<GameState_UnitsEntry_DoNotUse, 
    ::google::protobuf::uint64, ::Unit,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  GameState_UnitsEntry_DoNotUse();
  GameState_UnitsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const GameState_UnitsEntry_DoNotUse& other);
  static const GameState_UnitsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GameState_UnitsEntry_DoNotUse*>(&_GameState_UnitsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class GameState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameState) */ {
 public:
  GameState();
  virtual ~GameState();

  GameState(const GameState& from);

  inline GameState& operator=(const GameState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameState(GameState&& from) noexcept
    : GameState() {
    *this = ::std::move(from);
  }

  inline GameState& operator=(GameState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameState* internal_default_instance() {
    return reinterpret_cast<const GameState*>(
               &_GameState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(GameState* other);
  friend void swap(GameState& a, GameState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameState* New() const final {
    return CreateMaybeMessage<GameState>(NULL);
  }

  GameState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameState& from);
  void MergeFrom(const GameState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<uint64, .Unit> units = 3;
  int units_size() const;
  void clear_units();
  static const int kUnitsFieldNumber = 3;
  const ::google::protobuf::Map< ::google::protobuf::uint64, ::Unit >&
      units() const;
  ::google::protobuf::Map< ::google::protobuf::uint64, ::Unit >*
      mutable_units();

  // repeated .Tile tiles = 4;
  int tiles_size() const;
  void clear_tiles();
  static const int kTilesFieldNumber = 4;
  ::Tile* mutable_tiles(int index);
  ::google::protobuf::RepeatedPtrField< ::Tile >*
      mutable_tiles();
  const ::Tile& tiles(int index) const;
  ::Tile* add_tiles();
  const ::google::protobuf::RepeatedPtrField< ::Tile >&
      tiles() const;

  // .Command last_command = 5;
  bool has_last_command() const;
  void clear_last_command();
  static const int kLastCommandFieldNumber = 5;
  private:
  const ::Command& _internal_last_command() const;
  public:
  const ::Command& last_command() const;
  ::Command* release_last_command();
  ::Command* mutable_last_command();
  void set_allocated_last_command(::Command* last_command);

  // uint32 active_player = 1;
  void clear_active_player();
  static const int kActivePlayerFieldNumber = 1;
  ::google::protobuf::uint32 active_player() const;
  void set_active_player(::google::protobuf::uint32 value);

  // uint32 player = 2;
  void clear_player();
  static const int kPlayerFieldNumber = 2;
  ::google::protobuf::uint32 player() const;
  void set_player(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GameState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      GameState_UnitsEntry_DoNotUse,
      ::google::protobuf::uint64, ::Unit,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > units_;
  ::google::protobuf::RepeatedPtrField< ::Tile > tiles_;
  ::Command* last_command_;
  ::google::protobuf::uint32 active_player_;
  ::google::protobuf::uint32 player_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Position) */ {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(Position&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Position* other);
  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Position* New() const final {
    return CreateMaybeMessage<Position>(NULL);
  }

  Position* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 col = 1;
  void clear_col();
  static const int kColFieldNumber = 1;
  ::google::protobuf::uint32 col() const;
  void set_col(::google::protobuf::uint32 value);

  // uint32 row = 2;
  void clear_row();
  static const int kRowFieldNumber = 2;
  ::google::protobuf::uint32 row() const;
  void set_row(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Position)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 col_;
  ::google::protobuf::uint32 row_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Tile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Tile) */ {
 public:
  Tile();
  virtual ~Tile();

  Tile(const Tile& from);

  inline Tile& operator=(const Tile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Tile(Tile&& from) noexcept
    : Tile() {
    *this = ::std::move(from);
  }

  inline Tile& operator=(Tile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Tile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tile* internal_default_instance() {
    return reinterpret_cast<const Tile*>(
               &_Tile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Tile* other);
  friend void swap(Tile& a, Tile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Tile* New() const final {
    return CreateMaybeMessage<Tile>(NULL);
  }

  Tile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Tile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Tile& from);
  void MergeFrom(const Tile& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Position pos = 1;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 1;
  private:
  const ::Position& _internal_pos() const;
  public:
  const ::Position& pos() const;
  ::Position* release_pos();
  ::Position* mutable_pos();
  void set_allocated_pos(::Position* pos);

  // uint32 terrain = 2;
  void clear_terrain();
  static const int kTerrainFieldNumber = 2;
  ::google::protobuf::uint32 terrain() const;
  void set_terrain(::google::protobuf::uint32 value);

  // bool occupied = 3;
  void clear_occupied();
  static const int kOccupiedFieldNumber = 3;
  bool occupied() const;
  void set_occupied(bool value);

  // @@protoc_insertion_point(class_scope:Tile)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Position* pos_;
  ::google::protobuf::uint32 terrain_;
  bool occupied_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Unit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Unit) */ {
 public:
  Unit();
  virtual ~Unit();

  Unit(const Unit& from);

  inline Unit& operator=(const Unit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Unit(Unit&& from) noexcept
    : Unit() {
    *this = ::std::move(from);
  }

  inline Unit& operator=(Unit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Unit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Unit* internal_default_instance() {
    return reinterpret_cast<const Unit*>(
               &_Unit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Unit* other);
  friend void swap(Unit& a, Unit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Unit* New() const final {
    return CreateMaybeMessage<Unit>(NULL);
  }

  Unit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Unit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Unit& from);
  void MergeFrom(const Unit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Unit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Position position = 3;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  private:
  const ::Position& _internal_position() const;
  public:
  const ::Position& position() const;
  ::Position* release_position();
  ::Position* mutable_position();
  void set_allocated_position(::Position* position);

  // uint32 player = 1;
  void clear_player();
  static const int kPlayerFieldNumber = 1;
  ::google::protobuf::uint32 player() const;
  void set_player(::google::protobuf::uint32 value);

  // uint32 type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // int32 health = 4;
  void clear_health();
  static const int kHealthFieldNumber = 4;
  ::google::protobuf::int32 health() const;
  void set_health(::google::protobuf::int32 value);

  // int32 action_points = 5;
  void clear_action_points();
  static const int kActionPointsFieldNumber = 5;
  ::google::protobuf::int32 action_points() const;
  void set_action_points(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Unit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Position* position_;
  ::google::protobuf::uint32 player_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::int32 health_;
  ::google::protobuf::int32 action_points_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(Command&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  enum CommandCase {
    kEndTurn = 1,
    kMove = 2,
    kDirectAttack = 3,
    kSpawn = 4,
    COMMAND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Command* other);
  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const final {
    return CreateMaybeMessage<Command>(NULL);
  }

  Command* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .EndTurn end_turn = 1;
  bool has_end_turn() const;
  void clear_end_turn();
  static const int kEndTurnFieldNumber = 1;
  private:
  const ::EndTurn& _internal_end_turn() const;
  public:
  const ::EndTurn& end_turn() const;
  ::EndTurn* release_end_turn();
  ::EndTurn* mutable_end_turn();
  void set_allocated_end_turn(::EndTurn* end_turn);

  // .Move move = 2;
  bool has_move() const;
  void clear_move();
  static const int kMoveFieldNumber = 2;
  private:
  const ::Move& _internal_move() const;
  public:
  const ::Move& move() const;
  ::Move* release_move();
  ::Move* mutable_move();
  void set_allocated_move(::Move* move);

  // .DirectAttack direct_attack = 3;
  bool has_direct_attack() const;
  void clear_direct_attack();
  static const int kDirectAttackFieldNumber = 3;
  private:
  const ::DirectAttack& _internal_direct_attack() const;
  public:
  const ::DirectAttack& direct_attack() const;
  ::DirectAttack* release_direct_attack();
  ::DirectAttack* mutable_direct_attack();
  void set_allocated_direct_attack(::DirectAttack* direct_attack);

  // .Spawn spawn = 4;
  bool has_spawn() const;
  void clear_spawn();
  static const int kSpawnFieldNumber = 4;
  private:
  const ::Spawn& _internal_spawn() const;
  public:
  const ::Spawn& spawn() const;
  ::Spawn* release_spawn();
  ::Spawn* mutable_spawn();
  void set_allocated_spawn(::Spawn* spawn);

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:Command)
 private:
  void set_has_end_turn();
  void set_has_move();
  void set_has_direct_attack();
  void set_has_spawn();

  inline bool has_command() const;
  inline void clear_has_command();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union CommandUnion {
    CommandUnion() {}
    ::EndTurn* end_turn_;
    ::Move* move_;
    ::DirectAttack* direct_attack_;
    ::Spawn* spawn_;
  } command_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EndTurn : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EndTurn) */ {
 public:
  EndTurn();
  virtual ~EndTurn();

  EndTurn(const EndTurn& from);

  inline EndTurn& operator=(const EndTurn& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EndTurn(EndTurn&& from) noexcept
    : EndTurn() {
    *this = ::std::move(from);
  }

  inline EndTurn& operator=(EndTurn&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EndTurn& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EndTurn* internal_default_instance() {
    return reinterpret_cast<const EndTurn*>(
               &_EndTurn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(EndTurn* other);
  friend void swap(EndTurn& a, EndTurn& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EndTurn* New() const final {
    return CreateMaybeMessage<EndTurn>(NULL);
  }

  EndTurn* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EndTurn>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EndTurn& from);
  void MergeFrom(const EndTurn& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EndTurn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:EndTurn)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Move : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Move) */ {
 public:
  Move();
  virtual ~Move();

  Move(const Move& from);

  inline Move& operator=(const Move& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Move(Move&& from) noexcept
    : Move() {
    *this = ::std::move(from);
  }

  inline Move& operator=(Move&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Move& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Move* internal_default_instance() {
    return reinterpret_cast<const Move*>(
               &_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Move* other);
  friend void swap(Move& a, Move& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Move* New() const final {
    return CreateMaybeMessage<Move>(NULL);
  }

  Move* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Move>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Move& from);
  void MergeFrom(const Move& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Move* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Position position = 2;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  private:
  const ::Position& _internal_position() const;
  public:
  const ::Position& position() const;
  ::Position* release_position();
  ::Position* mutable_position();
  void set_allocated_position(::Position* position);

  // uint64 unit_id = 1;
  void clear_unit_id();
  static const int kUnitIdFieldNumber = 1;
  ::google::protobuf::uint64 unit_id() const;
  void set_unit_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Move)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Position* position_;
  ::google::protobuf::uint64 unit_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DirectAttack : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DirectAttack) */ {
 public:
  DirectAttack();
  virtual ~DirectAttack();

  DirectAttack(const DirectAttack& from);

  inline DirectAttack& operator=(const DirectAttack& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DirectAttack(DirectAttack&& from) noexcept
    : DirectAttack() {
    *this = ::std::move(from);
  }

  inline DirectAttack& operator=(DirectAttack&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectAttack& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectAttack* internal_default_instance() {
    return reinterpret_cast<const DirectAttack*>(
               &_DirectAttack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(DirectAttack* other);
  friend void swap(DirectAttack& a, DirectAttack& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectAttack* New() const final {
    return CreateMaybeMessage<DirectAttack>(NULL);
  }

  DirectAttack* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DirectAttack>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DirectAttack& from);
  void MergeFrom(const DirectAttack& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectAttack* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 unit_id = 1;
  void clear_unit_id();
  static const int kUnitIdFieldNumber = 1;
  ::google::protobuf::uint64 unit_id() const;
  void set_unit_id(::google::protobuf::uint64 value);

  // uint64 target_id = 2;
  void clear_target_id();
  static const int kTargetIdFieldNumber = 2;
  ::google::protobuf::uint64 target_id() const;
  void set_target_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:DirectAttack)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 unit_id_;
  ::google::protobuf::uint64 target_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Spawn : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Spawn) */ {
 public:
  Spawn();
  virtual ~Spawn();

  Spawn(const Spawn& from);

  inline Spawn& operator=(const Spawn& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Spawn(Spawn&& from) noexcept
    : Spawn() {
    *this = ::std::move(from);
  }

  inline Spawn& operator=(Spawn&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Spawn& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Spawn* internal_default_instance() {
    return reinterpret_cast<const Spawn*>(
               &_Spawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Spawn* other);
  friend void swap(Spawn& a, Spawn& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Spawn* New() const final {
    return CreateMaybeMessage<Spawn>(NULL);
  }

  Spawn* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Spawn>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Spawn& from);
  void MergeFrom(const Spawn& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Spawn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Position position = 3;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  private:
  const ::Position& _internal_position() const;
  public:
  const ::Position& position() const;
  ::Position* release_position();
  ::Position* mutable_position();
  void set_allocated_position(::Position* position);

  // uint64 unit_id = 1;
  void clear_unit_id();
  static const int kUnitIdFieldNumber = 1;
  ::google::protobuf::uint64 unit_id() const;
  void set_unit_id(::google::protobuf::uint64 value);

  // uint32 unit_type = 2;
  void clear_unit_type();
  static const int kUnitTypeFieldNumber = 2;
  ::google::protobuf::uint32 unit_type() const;
  void set_unit_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Spawn)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Position* position_;
  ::google::protobuf::uint64 unit_id_;
  ::google::protobuf::uint32 unit_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// GameState

// uint32 active_player = 1;
inline void GameState::clear_active_player() {
  active_player_ = 0u;
}
inline ::google::protobuf::uint32 GameState::active_player() const {
  // @@protoc_insertion_point(field_get:GameState.active_player)
  return active_player_;
}
inline void GameState::set_active_player(::google::protobuf::uint32 value) {
  
  active_player_ = value;
  // @@protoc_insertion_point(field_set:GameState.active_player)
}

// uint32 player = 2;
inline void GameState::clear_player() {
  player_ = 0u;
}
inline ::google::protobuf::uint32 GameState::player() const {
  // @@protoc_insertion_point(field_get:GameState.player)
  return player_;
}
inline void GameState::set_player(::google::protobuf::uint32 value) {
  
  player_ = value;
  // @@protoc_insertion_point(field_set:GameState.player)
}

// map<uint64, .Unit> units = 3;
inline int GameState::units_size() const {
  return units_.size();
}
inline void GameState::clear_units() {
  units_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::uint64, ::Unit >&
GameState::units() const {
  // @@protoc_insertion_point(field_map:GameState.units)
  return units_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::uint64, ::Unit >*
GameState::mutable_units() {
  // @@protoc_insertion_point(field_mutable_map:GameState.units)
  return units_.MutableMap();
}

// repeated .Tile tiles = 4;
inline int GameState::tiles_size() const {
  return tiles_.size();
}
inline void GameState::clear_tiles() {
  tiles_.Clear();
}
inline ::Tile* GameState::mutable_tiles(int index) {
  // @@protoc_insertion_point(field_mutable:GameState.tiles)
  return tiles_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Tile >*
GameState::mutable_tiles() {
  // @@protoc_insertion_point(field_mutable_list:GameState.tiles)
  return &tiles_;
}
inline const ::Tile& GameState::tiles(int index) const {
  // @@protoc_insertion_point(field_get:GameState.tiles)
  return tiles_.Get(index);
}
inline ::Tile* GameState::add_tiles() {
  // @@protoc_insertion_point(field_add:GameState.tiles)
  return tiles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Tile >&
GameState::tiles() const {
  // @@protoc_insertion_point(field_list:GameState.tiles)
  return tiles_;
}

// .Command last_command = 5;
inline bool GameState::has_last_command() const {
  return this != internal_default_instance() && last_command_ != NULL;
}
inline void GameState::clear_last_command() {
  if (GetArenaNoVirtual() == NULL && last_command_ != NULL) {
    delete last_command_;
  }
  last_command_ = NULL;
}
inline const ::Command& GameState::_internal_last_command() const {
  return *last_command_;
}
inline const ::Command& GameState::last_command() const {
  const ::Command* p = last_command_;
  // @@protoc_insertion_point(field_get:GameState.last_command)
  return p != NULL ? *p : *reinterpret_cast<const ::Command*>(
      &::_Command_default_instance_);
}
inline ::Command* GameState::release_last_command() {
  // @@protoc_insertion_point(field_release:GameState.last_command)
  
  ::Command* temp = last_command_;
  last_command_ = NULL;
  return temp;
}
inline ::Command* GameState::mutable_last_command() {
  
  if (last_command_ == NULL) {
    auto* p = CreateMaybeMessage<::Command>(GetArenaNoVirtual());
    last_command_ = p;
  }
  // @@protoc_insertion_point(field_mutable:GameState.last_command)
  return last_command_;
}
inline void GameState::set_allocated_last_command(::Command* last_command) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete last_command_;
  }
  if (last_command) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      last_command = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, last_command, submessage_arena);
    }
    
  } else {
    
  }
  last_command_ = last_command;
  // @@protoc_insertion_point(field_set_allocated:GameState.last_command)
}

// -------------------------------------------------------------------

// Position

// uint32 col = 1;
inline void Position::clear_col() {
  col_ = 0u;
}
inline ::google::protobuf::uint32 Position::col() const {
  // @@protoc_insertion_point(field_get:Position.col)
  return col_;
}
inline void Position::set_col(::google::protobuf::uint32 value) {
  
  col_ = value;
  // @@protoc_insertion_point(field_set:Position.col)
}

// uint32 row = 2;
inline void Position::clear_row() {
  row_ = 0u;
}
inline ::google::protobuf::uint32 Position::row() const {
  // @@protoc_insertion_point(field_get:Position.row)
  return row_;
}
inline void Position::set_row(::google::protobuf::uint32 value) {
  
  row_ = value;
  // @@protoc_insertion_point(field_set:Position.row)
}

// -------------------------------------------------------------------

// Tile

// .Position pos = 1;
inline bool Tile::has_pos() const {
  return this != internal_default_instance() && pos_ != NULL;
}
inline void Tile::clear_pos() {
  if (GetArenaNoVirtual() == NULL && pos_ != NULL) {
    delete pos_;
  }
  pos_ = NULL;
}
inline const ::Position& Tile::_internal_pos() const {
  return *pos_;
}
inline const ::Position& Tile::pos() const {
  const ::Position* p = pos_;
  // @@protoc_insertion_point(field_get:Tile.pos)
  return p != NULL ? *p : *reinterpret_cast<const ::Position*>(
      &::_Position_default_instance_);
}
inline ::Position* Tile::release_pos() {
  // @@protoc_insertion_point(field_release:Tile.pos)
  
  ::Position* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline ::Position* Tile::mutable_pos() {
  
  if (pos_ == NULL) {
    auto* p = CreateMaybeMessage<::Position>(GetArenaNoVirtual());
    pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Tile.pos)
  return pos_;
}
inline void Tile::set_allocated_pos(::Position* pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pos_;
  }
  if (pos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:Tile.pos)
}

// uint32 terrain = 2;
inline void Tile::clear_terrain() {
  terrain_ = 0u;
}
inline ::google::protobuf::uint32 Tile::terrain() const {
  // @@protoc_insertion_point(field_get:Tile.terrain)
  return terrain_;
}
inline void Tile::set_terrain(::google::protobuf::uint32 value) {
  
  terrain_ = value;
  // @@protoc_insertion_point(field_set:Tile.terrain)
}

// bool occupied = 3;
inline void Tile::clear_occupied() {
  occupied_ = false;
}
inline bool Tile::occupied() const {
  // @@protoc_insertion_point(field_get:Tile.occupied)
  return occupied_;
}
inline void Tile::set_occupied(bool value) {
  
  occupied_ = value;
  // @@protoc_insertion_point(field_set:Tile.occupied)
}

// -------------------------------------------------------------------

// Unit

// uint32 player = 1;
inline void Unit::clear_player() {
  player_ = 0u;
}
inline ::google::protobuf::uint32 Unit::player() const {
  // @@protoc_insertion_point(field_get:Unit.player)
  return player_;
}
inline void Unit::set_player(::google::protobuf::uint32 value) {
  
  player_ = value;
  // @@protoc_insertion_point(field_set:Unit.player)
}

// uint32 type = 2;
inline void Unit::clear_type() {
  type_ = 0u;
}
inline ::google::protobuf::uint32 Unit::type() const {
  // @@protoc_insertion_point(field_get:Unit.type)
  return type_;
}
inline void Unit::set_type(::google::protobuf::uint32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Unit.type)
}

// .Position position = 3;
inline bool Unit::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline void Unit::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
}
inline const ::Position& Unit::_internal_position() const {
  return *position_;
}
inline const ::Position& Unit::position() const {
  const ::Position* p = position_;
  // @@protoc_insertion_point(field_get:Unit.position)
  return p != NULL ? *p : *reinterpret_cast<const ::Position*>(
      &::_Position_default_instance_);
}
inline ::Position* Unit::release_position() {
  // @@protoc_insertion_point(field_release:Unit.position)
  
  ::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::Position* Unit::mutable_position() {
  
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::Position>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Unit.position)
  return position_;
}
inline void Unit::set_allocated_position(::Position* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Unit.position)
}

// int32 health = 4;
inline void Unit::clear_health() {
  health_ = 0;
}
inline ::google::protobuf::int32 Unit::health() const {
  // @@protoc_insertion_point(field_get:Unit.health)
  return health_;
}
inline void Unit::set_health(::google::protobuf::int32 value) {
  
  health_ = value;
  // @@protoc_insertion_point(field_set:Unit.health)
}

// int32 action_points = 5;
inline void Unit::clear_action_points() {
  action_points_ = 0;
}
inline ::google::protobuf::int32 Unit::action_points() const {
  // @@protoc_insertion_point(field_get:Unit.action_points)
  return action_points_;
}
inline void Unit::set_action_points(::google::protobuf::int32 value) {
  
  action_points_ = value;
  // @@protoc_insertion_point(field_set:Unit.action_points)
}

// -------------------------------------------------------------------

// Command

// .EndTurn end_turn = 1;
inline bool Command::has_end_turn() const {
  return command_case() == kEndTurn;
}
inline void Command::set_has_end_turn() {
  _oneof_case_[0] = kEndTurn;
}
inline void Command::clear_end_turn() {
  if (has_end_turn()) {
    delete command_.end_turn_;
    clear_has_command();
  }
}
inline const ::EndTurn& Command::_internal_end_turn() const {
  return *command_.end_turn_;
}
inline ::EndTurn* Command::release_end_turn() {
  // @@protoc_insertion_point(field_release:Command.end_turn)
  if (has_end_turn()) {
    clear_has_command();
      ::EndTurn* temp = command_.end_turn_;
    command_.end_turn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::EndTurn& Command::end_turn() const {
  // @@protoc_insertion_point(field_get:Command.end_turn)
  return has_end_turn()
      ? *command_.end_turn_
      : *reinterpret_cast< ::EndTurn*>(&::_EndTurn_default_instance_);
}
inline ::EndTurn* Command::mutable_end_turn() {
  if (!has_end_turn()) {
    clear_command();
    set_has_end_turn();
    command_.end_turn_ = CreateMaybeMessage< ::EndTurn >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Command.end_turn)
  return command_.end_turn_;
}

// .Move move = 2;
inline bool Command::has_move() const {
  return command_case() == kMove;
}
inline void Command::set_has_move() {
  _oneof_case_[0] = kMove;
}
inline void Command::clear_move() {
  if (has_move()) {
    delete command_.move_;
    clear_has_command();
  }
}
inline const ::Move& Command::_internal_move() const {
  return *command_.move_;
}
inline ::Move* Command::release_move() {
  // @@protoc_insertion_point(field_release:Command.move)
  if (has_move()) {
    clear_has_command();
      ::Move* temp = command_.move_;
    command_.move_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Move& Command::move() const {
  // @@protoc_insertion_point(field_get:Command.move)
  return has_move()
      ? *command_.move_
      : *reinterpret_cast< ::Move*>(&::_Move_default_instance_);
}
inline ::Move* Command::mutable_move() {
  if (!has_move()) {
    clear_command();
    set_has_move();
    command_.move_ = CreateMaybeMessage< ::Move >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Command.move)
  return command_.move_;
}

// .DirectAttack direct_attack = 3;
inline bool Command::has_direct_attack() const {
  return command_case() == kDirectAttack;
}
inline void Command::set_has_direct_attack() {
  _oneof_case_[0] = kDirectAttack;
}
inline void Command::clear_direct_attack() {
  if (has_direct_attack()) {
    delete command_.direct_attack_;
    clear_has_command();
  }
}
inline const ::DirectAttack& Command::_internal_direct_attack() const {
  return *command_.direct_attack_;
}
inline ::DirectAttack* Command::release_direct_attack() {
  // @@protoc_insertion_point(field_release:Command.direct_attack)
  if (has_direct_attack()) {
    clear_has_command();
      ::DirectAttack* temp = command_.direct_attack_;
    command_.direct_attack_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::DirectAttack& Command::direct_attack() const {
  // @@protoc_insertion_point(field_get:Command.direct_attack)
  return has_direct_attack()
      ? *command_.direct_attack_
      : *reinterpret_cast< ::DirectAttack*>(&::_DirectAttack_default_instance_);
}
inline ::DirectAttack* Command::mutable_direct_attack() {
  if (!has_direct_attack()) {
    clear_command();
    set_has_direct_attack();
    command_.direct_attack_ = CreateMaybeMessage< ::DirectAttack >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Command.direct_attack)
  return command_.direct_attack_;
}

// .Spawn spawn = 4;
inline bool Command::has_spawn() const {
  return command_case() == kSpawn;
}
inline void Command::set_has_spawn() {
  _oneof_case_[0] = kSpawn;
}
inline void Command::clear_spawn() {
  if (has_spawn()) {
    delete command_.spawn_;
    clear_has_command();
  }
}
inline const ::Spawn& Command::_internal_spawn() const {
  return *command_.spawn_;
}
inline ::Spawn* Command::release_spawn() {
  // @@protoc_insertion_point(field_release:Command.spawn)
  if (has_spawn()) {
    clear_has_command();
      ::Spawn* temp = command_.spawn_;
    command_.spawn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Spawn& Command::spawn() const {
  // @@protoc_insertion_point(field_get:Command.spawn)
  return has_spawn()
      ? *command_.spawn_
      : *reinterpret_cast< ::Spawn*>(&::_Spawn_default_instance_);
}
inline ::Spawn* Command::mutable_spawn() {
  if (!has_spawn()) {
    clear_command();
    set_has_spawn();
    command_.spawn_ = CreateMaybeMessage< ::Spawn >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Command.spawn)
  return command_.spawn_;
}

inline bool Command::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void Command::clear_has_command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline Command::CommandCase Command::command_case() const {
  return Command::CommandCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// EndTurn

// -------------------------------------------------------------------

// Move

// uint64 unit_id = 1;
inline void Move::clear_unit_id() {
  unit_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Move::unit_id() const {
  // @@protoc_insertion_point(field_get:Move.unit_id)
  return unit_id_;
}
inline void Move::set_unit_id(::google::protobuf::uint64 value) {
  
  unit_id_ = value;
  // @@protoc_insertion_point(field_set:Move.unit_id)
}

// .Position position = 2;
inline bool Move::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline void Move::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
}
inline const ::Position& Move::_internal_position() const {
  return *position_;
}
inline const ::Position& Move::position() const {
  const ::Position* p = position_;
  // @@protoc_insertion_point(field_get:Move.position)
  return p != NULL ? *p : *reinterpret_cast<const ::Position*>(
      &::_Position_default_instance_);
}
inline ::Position* Move::release_position() {
  // @@protoc_insertion_point(field_release:Move.position)
  
  ::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::Position* Move::mutable_position() {
  
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::Position>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Move.position)
  return position_;
}
inline void Move::set_allocated_position(::Position* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Move.position)
}

// -------------------------------------------------------------------

// DirectAttack

// uint64 unit_id = 1;
inline void DirectAttack::clear_unit_id() {
  unit_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 DirectAttack::unit_id() const {
  // @@protoc_insertion_point(field_get:DirectAttack.unit_id)
  return unit_id_;
}
inline void DirectAttack::set_unit_id(::google::protobuf::uint64 value) {
  
  unit_id_ = value;
  // @@protoc_insertion_point(field_set:DirectAttack.unit_id)
}

// uint64 target_id = 2;
inline void DirectAttack::clear_target_id() {
  target_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 DirectAttack::target_id() const {
  // @@protoc_insertion_point(field_get:DirectAttack.target_id)
  return target_id_;
}
inline void DirectAttack::set_target_id(::google::protobuf::uint64 value) {
  
  target_id_ = value;
  // @@protoc_insertion_point(field_set:DirectAttack.target_id)
}

// -------------------------------------------------------------------

// Spawn

// uint64 unit_id = 1;
inline void Spawn::clear_unit_id() {
  unit_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Spawn::unit_id() const {
  // @@protoc_insertion_point(field_get:Spawn.unit_id)
  return unit_id_;
}
inline void Spawn::set_unit_id(::google::protobuf::uint64 value) {
  
  unit_id_ = value;
  // @@protoc_insertion_point(field_set:Spawn.unit_id)
}

// uint32 unit_type = 2;
inline void Spawn::clear_unit_type() {
  unit_type_ = 0u;
}
inline ::google::protobuf::uint32 Spawn::unit_type() const {
  // @@protoc_insertion_point(field_get:Spawn.unit_type)
  return unit_type_;
}
inline void Spawn::set_unit_type(::google::protobuf::uint32 value) {
  
  unit_type_ = value;
  // @@protoc_insertion_point(field_set:Spawn.unit_type)
}

// .Position position = 3;
inline bool Spawn::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline void Spawn::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
}
inline const ::Position& Spawn::_internal_position() const {
  return *position_;
}
inline const ::Position& Spawn::position() const {
  const ::Position* p = position_;
  // @@protoc_insertion_point(field_get:Spawn.position)
  return p != NULL ? *p : *reinterpret_cast<const ::Position*>(
      &::_Position_default_instance_);
}
inline ::Position* Spawn::release_position() {
  // @@protoc_insertion_point(field_release:Spawn.position)
  
  ::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::Position* Spawn::mutable_position() {
  
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::Position>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Spawn.position)
  return position_;
}
inline void Spawn::set_allocated_position(::Position* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Spawn.position)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_protocol_2eproto
